
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logError, formatErrorMessage } from '@/utils/errorLogger';

const SUPABASE_URL = "https://fuqibkjdvpmbegibcyhl.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ1cWlia2pkdnBtYmVnaWJjeWhsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0MzE5OTIsImV4cCI6MjA2MjAwNzk5Mn0.xuOIxiIPB6QSsTdWRKxb3YLrUYA6__AWz0eBZz1Wx9Q";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY, 
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true
    },
    global: {
      headers: {
        'Content-Type': 'application/json'
      }
    }
  }
);

/**
 * Check if the current session is valid
 * @returns boolean indicating if the session is valid
 */
export const checkAuthSession = async (): Promise<boolean> => {
  try {
    const { data, error } = await supabase.auth.getSession();
    if (error) {
      logError("Auth session error", error.message);
      return false;
    }
    
    const session = data?.session;
    const isValid = !!session && new Date(session.expires_at * 1000) > new Date();
    console.log("Auth session check:", { 
      hasSession: !!session, 
      isValid,
      expiresAt: session ? new Date(session.expires_at * 1000).toISOString() : 'none',
      userId: session?.user?.id || 'not authenticated'
    });
    
    return isValid;
  } catch (error) {
    logError("Exception checking auth session", formatErrorMessage(error));
    return false;
  }
};

/**
 * Invokes a Supabase Edge Function with the given name and payload
 * @param functionName The name of the Edge Function to invoke
 * @param payload The payload to send to the Edge Function
 * @returns The response from the Edge Function
 */
export const invokeEdgeFunction = async <T = any>(functionName: string, payload?: any): Promise<T> => {
  // Set a global timeout for the entire function
  const FUNCTION_TIMEOUT_MS = 30000; // 30 seconds
  
  try {
    // Check auth session before calling the edge function
    const isSessionValid = await checkAuthSession();
    if (!isSessionValid) {
      const errorMsg = "Authentication session is invalid or expired. Please sign in again.";
      logError("Auth Error", errorMsg);
      throw new Error(errorMsg);
    }
    
    // Get fresh auth session to include in the invocation
    const { data: authData } = await supabase.auth.getSession();
    
    // Add origin information to help with CORS debugging
    const enhancedPayload = {
      ...payload,
      clientInfo: {
        ...(payload?.clientInfo || {}),
        origin: window.location.origin,
        host: window.location.host,
        href: window.location.href,
        clientTimestamp: new Date().toISOString(),
        userAgent: navigator.userAgent
      },
      sessionInfo: {
        userId: authData?.session?.user?.id,
        hasSession: !!authData?.session,
        expiresAt: authData?.session ? new Date(authData.session.expires_at * 1000).toISOString() : 'none'
      }
    };
    
    console.log(`Invoking edge function ${functionName} with:`, enhancedPayload);
    
    // First try direct fetch to check if the function is accessible
    // This can help identify network vs. function issues
    try {
      console.log("Testing direct access to edge function...");
      const testUrl = `${SUPABASE_URL}/functions/v1/${functionName}`;
      
      // Log the exact URL we're trying to access
      console.log(`Attempting to access: ${testUrl}`);
      
      // Just do an OPTIONS request to check connectivity
      const testResponse = await fetch(testUrl, {
        method: 'OPTIONS',
        headers: {
          'Origin': window.location.origin,
        }
      });
      
      console.log("Direct edge function access test result:", {
        status: testResponse.status,
        statusText: testResponse.statusText,
        headers: Object.fromEntries(testResponse.headers.entries()),
        ok: testResponse.ok
      });
    } catch (testError) {
      // Log the error but don't throw, as this is just a test
      console.error("Edge function direct access test failed:", testError);
      console.log("This could indicate a network connectivity issue or CORS problem");
    }

    // Try the actual invocation through Supabase client
    console.log(`Now trying official invocation of ${functionName} via Supabase client...`);
    
    // Create promise with timeout
    const functionPromise = new Promise<T>(async (resolve, reject) => {
      try {
        const controller = new AbortController();
        
        // Set timeout for the fetch operation
        const timeoutId = setTimeout(() => {
          controller.abort();
          reject(new Error(`Edge function ${functionName} timed out after ${FUNCTION_TIMEOUT_MS / 1000} seconds`));
        }, FUNCTION_TIMEOUT_MS);
        
        // Include more debugging info in headers
        const additionalHeaders = {
          'X-Client-Origin': window.location.origin,
          'X-Client-Info': navigator.userAgent
        };

        // Invoke the Edge Function
        try {
          console.log(`Invoking ${functionName} edge function...`);
          
          // Try the official Supabase method first
          const { data, error } = await supabase.functions.invoke<T>(functionName, {
            body: enhancedPayload,
            headers: additionalHeaders
          });
          
          // Clear timeout since the request completed
          clearTimeout(timeoutId);
          
          if (error) {
            // Enhanced error logging and handling
            console.error(`Error invoking ${functionName}:`, error);
            
            // Extract error details for better diagnostics
            let errorMessage = `Error calling ${functionName}`;
            
            if ('message' in error && typeof (error as any).message === 'string') {
              errorMessage = (error as any).message;
              
              // Check for specific error patterns
              if (errorMessage.includes('net::ERR_FAILED') || 
                  errorMessage.includes('Failed to fetch') || 
                  errorMessage.includes('NetworkError')) {
                errorMessage = `Network error calling ${functionName}. This may indicate the function is not deployed or there is a server configuration issue. Check the Supabase dashboard to verify the function is deployed.`;
              }
              else if (errorMessage.includes('CORS') || errorMessage.includes('cross-origin')) {
                errorMessage = `CORS error calling ${functionName}. Please ensure the function is deployed and configured correctly.`;
              }
              else if (errorMessage.includes('404') || errorMessage.toLowerCase().includes('not found')) {
                errorMessage = `Edge function ${functionName} not found (404). Please verify the function is correctly deployed to your Supabase project.`;
              }
            } 
            
            reject(new Error(errorMessage));
            return;
          }
          
          console.log(`Edge function ${functionName} response:`, data);
          resolve(data);
        } catch (invocationError) {
          clearTimeout(timeoutId);
          console.error(`Exception during invocation of ${functionName}:`, invocationError);
          
          // Special handling for low-level network errors
          const errorString = String(invocationError);
          if (errorString.includes('net::ERR_FAILED') || 
              errorString.includes('Failed to fetch') || 
              errorString.includes('NetworkError')) {
            reject(new Error(`Network error calling ${functionName}. This may indicate the function is not deployed or there is a server configuration issue. Check the Supabase dashboard to verify the function is deployed.`));
          } else {
            reject(invocationError);
          }
        }
      } catch (error) {
        reject(error);
      }
    });
    
    // When all else fails, try a direct fetch as a last resort
    try {
      const result = await functionPromise;
      return result;
    } catch (supabaseError) {
      console.error("Supabase client invocation failed:", supabaseError);
      console.log("Attempting direct fetch as fallback...");
      
      try {
        // Try direct fetch as a last resort
        const directUrl = `${SUPABASE_URL}/functions/v1/${functionName}`;
        console.log(`Attempting direct fetch to: ${directUrl}`);
        
        const { data: authData } = await supabase.auth.getSession();
        const jwt = authData?.session?.access_token;
        
        if (!jwt) {
          throw new Error("No access token available for direct function call");
        }
        
        const directResponse = await fetch(directUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${jwt}`,
            'Origin': window.location.origin
          },
          body: JSON.stringify(enhancedPayload)
        });
        
        console.log("Direct fetch response:", {
          status: directResponse.status,
          statusText: directResponse.statusText,
          headers: Object.fromEntries(directResponse.headers.entries())
        });
        
        if (!directResponse.ok) {
          const errorText = await directResponse.text();
          throw new Error(`Direct fetch failed: ${directResponse.status} ${directResponse.statusText} - ${errorText}`);
        }
        
        const directData = await directResponse.json();
        console.log("Direct fetch successful:", directData);
        return directData as T;
      } catch (directError) {
        console.error("Direct fetch also failed:", directError);
        throw supabaseError; // Throw the original error
      }
    }
    
  } catch (error) {
    console.error(`Exception invoking ${functionName}:`, error);
    
    // Enhanced error detection for better user feedback
    const errorString = String(error);
    
    // Specific network error detection
    if (errorString.includes('net::ERR_FAILED') || 
        errorString.includes('Failed to fetch') || 
        errorString.includes('NetworkError')) {
      console.error('Network error detected in edge function invocation');
      console.error('Client origin:', window.location.origin);
      console.error('Requested function:', functionName);
      throw new Error(`Network error calling ${functionName}. This likely means the function is not deployed or there's a server configuration issue. Please check the Supabase dashboard to verify the function is deployed.`);
    }
    
    // Specific CORS error detection
    if (errorString.includes('CORS') || errorString.includes('cross-origin')) {
      console.error('CORS error detected in edge function invocation');
      console.error('Client origin:', window.location.origin);
      console.error('Requested function:', functionName);
      throw new Error(`CORS error calling ${functionName}. This is likely a server configuration issue. Please try again later.`);
    }
    
    // Specific 404 error detection
    if (errorString.includes('404') || errorString.toLowerCase().includes('not found')) {
      console.error(`Function not found (404): ${functionName}`);
      throw new Error(`Edge function ${functionName} not found (404). Please verify it is deployed correctly.`);
    }
    
    // Extract error details for better user feedback
    let errorMessage = formatErrorMessage(error);
    
    // Rethrow with formatted message
    throw new Error(errorMessage);
  }
};
