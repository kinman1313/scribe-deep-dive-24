
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logError, formatErrorMessage } from '@/utils/errorLogger';

const SUPABASE_URL = "https://fuqibkjdvpmbegibcyhl.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ1cWlia2pkdnBtYmVnaWJjeWhsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0MzE5OTIsImV4cCI6MjA2MjAwNzk5Mn0.xuOIxiIPB6QSsTdWRKxb3YLrUYA6__AWz0eBZz1Wx9Q";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY, 
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true
    },
    global: {
      headers: {
        'Content-Type': 'application/json'
      }
    }
  }
);

/**
 * Check if the current session is valid
 * @returns boolean indicating if the session is valid
 */
export const checkAuthSession = async (): Promise<boolean> => {
  try {
    const { data, error } = await supabase.auth.getSession();
    if (error) {
      logError("Auth session error", error.message);
      return false;
    }
    
    const session = data?.session;
    const isValid = !!session && new Date(session.expires_at * 1000) > new Date();
    console.log("Auth session check:", { 
      hasSession: !!session, 
      isValid,
      expiresAt: session ? new Date(session.expires_at * 1000).toISOString() : 'none',
      userId: session?.user?.id || 'not authenticated'
    });
    
    return isValid;
  } catch (error) {
    logError("Exception checking auth session", formatErrorMessage(error));
    return false;
  }
};

/**
 * Invokes a Supabase Edge Function with the given name and payload
 * @param functionName The name of the Edge Function to invoke
 * @param payload The payload to send to the Edge Function
 * @returns The response from the Edge Function
 */
export const invokeEdgeFunction = async <T = any>(functionName: string, payload?: any): Promise<T> => {
  // Set a global timeout for the entire function
  const FUNCTION_TIMEOUT_MS = 30000; // 30 seconds
  
  try {
    // Check auth session before calling the edge function
    const isSessionValid = await checkAuthSession();
    if (!isSessionValid) {
      const errorMsg = "Authentication session is invalid or expired. Please sign in again.";
      logError("Auth Error", errorMsg);
      throw new Error(errorMsg);
    }
    
    // Get fresh auth session to include in the invocation
    const { data: authData } = await supabase.auth.getSession();
    
    // Add origin information to help with CORS debugging
    const enhancedPayload = {
      ...payload,
      clientInfo: {
        ...(payload?.clientInfo || {}),
        origin: window.location.origin,
        host: window.location.host,
        href: window.location.href,
        clientTimestamp: new Date().toISOString()
      },
      sessionInfo: {
        userId: authData?.session?.user?.id,
        hasSession: !!authData?.session,
        expiresAt: authData?.session ? new Date(authData.session.expires_at * 1000).toISOString() : 'none'
      }
    };
    
    console.log(`Invoking edge function ${functionName} with:`, enhancedPayload);
    
    // Create promise with timeout
    const functionPromise = new Promise<T>(async (resolve, reject) => {
      try {
        const controller = new AbortController();
        
        // Set timeout for the fetch operation
        const timeoutId = setTimeout(() => {
          controller.abort();
          reject(new Error(`Edge function ${functionName} timed out after ${FUNCTION_TIMEOUT_MS / 1000} seconds`));
        }, FUNCTION_TIMEOUT_MS);
        
        // Include more debugging info in headers
        const additionalHeaders = {
          'X-Client-Origin': window.location.origin,
          'X-Client-Info': navigator.userAgent
        };
        
        const { data, error } = await supabase.functions.invoke<T>(functionName, {
          body: enhancedPayload,
          headers: additionalHeaders
        });
        
        // Clear timeout since the request completed
        clearTimeout(timeoutId);
        
        if (error) {
          console.error(`Error invoking ${functionName}:`, error);
          
          // Enhanced error logging for debugging
          console.error('Edge Function Error Details:', JSON.stringify(error, null, 2));
          
          // Extract specific error properties if they exist
          if ('message' in error) console.error('Error message:', (error as any).message);
          if ('status' in error) console.error('Status code:', (error as any).status);
          if ('data' in error) console.error('Error data:', (error as any).data);
          
          // Extract user-friendly error message if possible
          let errorMessage = `Error calling ${functionName}`;
          if ('message' in error && typeof (error as any).message === 'string') {
            errorMessage = (error as any).message;
          } else if ('error' in error && typeof (error as any).error === 'string') {
            errorMessage = (error as any).error;
          } else if ('error' in error && typeof (error as any).error === 'object' && (error as any).error && 'message' in (error as any).error) {
            errorMessage = (error as any).error.message;
          }
          
          reject(new Error(errorMessage));
          return;
        }
        
        console.log(`Edge function ${functionName} response:`, data);
        resolve(data);
      } catch (error) {
        reject(error);
      }
    });
    
    // Execute the promise
    return await functionPromise;
  } catch (error) {
    console.error(`Exception invoking ${functionName}:`, error);
    
    // Specific CORS error detection
    const errorString = String(error);
    if (errorString.includes('CORS') || errorString.includes('cross-origin')) {
      console.error('CORS error detected in edge function invocation');
      console.error('Client origin:', window.location.origin);
      console.error('Requested function:', functionName);
      throw new Error(`CORS error calling ${functionName}. This is likely a server configuration issue.`);
    }
    
    // Extract error details for better user feedback
    let errorMessage = formatErrorMessage(error);
    
    // Rethrow with formatted message
    throw new Error(errorMessage);
  }
};
